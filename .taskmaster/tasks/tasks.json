{
  "master": {
    "tasks": [
      {
        "id": 13,
        "title": "Setup TypeScript MCP Server Foundation",
        "description": "Create the basic TypeScript MCP server implementation with stdio and HTTP/SSE transport support following cco-mcp best practices [Updated: 7/10/2025] [Updated: 7/10/2025]",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "Initialize TypeScript project with proper tsconfig.json, package.json with MCP dependencies. Implement base MCP server class with stdio transport support using @modelcontextprotocol/sdk-typescript. Add HTTP/SSE transport layer for web client compatibility. Create server initialization logic with transport selection. Follow patterns from cco-mcp reference implementation for type safety and structure.\n<info added on 2025-07-10T17:26:01.277Z>\nAssigned to claude-squad session-1720651200\n</info added on 2025-07-10T17:26:01.277Z>",
        "testStrategy": "Unit tests for server initialization, transport layer tests for both stdio and HTTP/SSE, integration tests with mock MCP clients",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Implement .mcp.json Configuration Parser",
        "description": "Create parser to read and validate .mcp.json configuration files and extract server connection details [Updated: 7/10/2025]",
        "details": "Build TypeScript configuration parser that reads .mcp.json files, validates schema, and extracts server definitions including transport types (stdio/HTTP), command paths, and connection parameters. Create TypeScript interfaces for configuration structure. Handle file system operations with proper error handling for missing or malformed configuration files. Support both absolute and relative paths for server executables.\n<info added on 2025-07-10T16:23:05.038Z>\nAssigned to claude-squad session-1736519135\n</info added on 2025-07-10T16:23:05.038Z>",
        "testStrategy": "Unit tests with various .mcp.json formats, validation tests for malformed configs, file system mock tests",
        "priority": "high",
        "dependencies": [
          13
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Build Client Connection Manager",
        "description": "Implement connection pool management system to establish and maintain connections to multiple underlying MCP servers [Updated: 7/10/2025]",
        "details": "Create connection manager that spawns and maintains connections to underlying MCP servers based on parsed configuration. Implement connection pooling with proper lifecycle management (connect, disconnect, reconnect). Support both stdio and HTTP transport protocols. Handle connection failures with retry logic and connection state tracking. Use TypeScript generics for type-safe connection handling.\n<info added on 2025-07-10T18:34:50.880Z>\nAssigned to claude-squad session-1736539652\n</info added on 2025-07-10T18:34:50.880Z>",
        "testStrategy": "Integration tests with mock MCP servers, connection lifecycle tests, failure scenario tests, concurrent connection tests",
        "priority": "high",
        "dependencies": [
          14
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Develop Tool Discovery Engine",
        "description": "Create system to query underlying servers for available tools and cache results with full TypeScript type safety",
        "details": "Implement tool discovery mechanism that queries connected MCP servers for their available tools using MCP list_tools protocol. Create TypeScript interfaces for tool metadata including schemas, descriptions, and server origins. Build caching layer with TTL and invalidation strategies. Handle tool schema conflicts with namespacing (server.tool_name format). Store tool definitions in memory with efficient lookup structures.",
        "testStrategy": "Unit tests for tool discovery logic, caching tests with TTL validation, schema conflict resolution tests, performance tests for large tool sets",
        "priority": "high",
        "dependencies": [
          15
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Create Request Router",
        "description": "Implement routing system to transparently route incoming tool requests to appropriate underlying servers [Updated: 7/10/2025]",
        "details": "Build request router that intercepts tool calls from clients and routes them to correct underlying MCP servers. Implement tool name resolution with namespace handling. Create request/response transformation layer to maintain protocol compatibility. Handle request parameters validation and response formatting. Add request logging and error propagation from underlying servers.\n<info added on 2025-07-10T19:36:07.189Z>\nAssigned to claude-squad session-1736523380\n</info added on 2025-07-10T19:36:07.189Z>",
        "testStrategy": "Integration tests with multiple mock servers, request routing accuracy tests, error handling tests, performance benchmarks",
        "priority": "high",
        "dependencies": [
          16
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Implement Toolset Configuration System",
        "description": "Create JSON-based toolset configuration allowing users to specify which tools to expose from each server [Updated: 7/10/2025]",
        "details": "Design toolset configuration schema with JSON format supporting server-specific tool inclusion/exclusion rules. Create configuration validator and loader with TypeScript type definitions. Implement toolset filtering logic that respects user preferences. Support wildcard patterns and regex for tool selection. Create default configuration generator based on available tools.\n<info added on 2025-07-10T20:38:15.385Z>\nAssigned to claude-squad session-1736487412\n</info added on 2025-07-10T20:38:15.385Z>",
        "testStrategy": "Schema validation tests, configuration loading tests, tool filtering accuracy tests, wildcard pattern tests",
        "priority": "medium",
        "dependencies": [
          17
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Add Server Health Monitoring",
        "description": "Implement health monitoring system to track underlying server availability with reconnection logic",
        "details": "Create health monitor that periodically checks underlying server availability using MCP ping/health check mechanisms. Implement reconnection logic with exponential backoff for failed connections. Track server status (online/offline/error) and update tool availability accordingly. Add health check scheduling and connection recovery procedures. Emit health events for monitoring.",
        "testStrategy": "Health check interval tests, reconnection logic tests, server failure simulation tests, health event emission tests",
        "priority": "medium",
        "dependencies": [
          15
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Build Configuration Persistence Layer",
        "description": "Create system to save user preferences and toolset configurations with file-based persistence",
        "details": "Implement file-based persistence for user toolset configurations using JSON format. Create configuration file management with atomic writes and backup strategies. Support configuration versioning and migration. Add user preference storage for default toolsets and server settings. Implement configuration validation on load with schema checking.",
        "testStrategy": "File persistence tests, atomic write tests, configuration migration tests, concurrent access tests",
        "priority": "medium",
        "dependencies": [
          18
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "Create CLI Interface for Toolset Management",
        "description": "Develop command-line interface for toolset management operations (create, save, load, list) [Updated: 7/13/2025]",
        "details": "Build CLI using commander.js or similar framework with commands for toolset management. Implement 'create', 'save', 'load', 'list', and 'delete' commands for toolset configurations. Add interactive toolset builder with server and tool selection menus. Create configuration import/export functionality. Include help documentation and command validation.\n<info added on 2025-07-13T16:52:13.067Z>\nAssigned to claude-squad session-1736790037\n</info added on 2025-07-13T16:52:13.067Z>",
        "testStrategy": "CLI command tests, interactive menu tests, configuration import/export tests, help system tests",
        "priority": "medium",
        "dependencies": [
          20
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Implement Error Handling and Logging",
        "description": "Add comprehensive error handling with clear warnings for unavailable servers and failed tool calls",
        "details": "Create structured error handling system with custom error classes for different failure scenarios. Implement logging framework with configurable log levels and output formatting. Add user-friendly error messages for common issues (server unavailable, tool not found, configuration errors). Create error recovery mechanisms and graceful degradation strategies.",
        "testStrategy": "Error scenario tests, logging output tests, error recovery tests, graceful degradation tests",
        "priority": "medium",
        "dependencies": [
          19
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "Add Tool Call Middleware and Debugging",
        "description": "Implement middleware system for tool call logging, debugging, and request/response transformation",
        "details": "Create middleware architecture for tool call interception and processing. Add request/response logging middleware with configurable verbosity. Implement debugging middleware with request tracing and performance metrics. Create tool call analytics middleware for usage tracking. Support middleware chaining and conditional execution based on configuration.",
        "testStrategy": "Middleware execution tests, logging middleware tests, debugging output tests, performance metrics tests",
        "priority": "low",
        "dependencies": [
          17
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "Create Comprehensive Testing Suite",
        "description": "Develop full testing suite including unit tests, integration tests, and end-to-end testing scenarios",
        "details": "Build comprehensive test suite using Jest or similar framework. Create unit tests for all core components with high coverage. Implement integration tests with mock MCP servers and real protocol interactions. Add end-to-end tests simulating complete user workflows. Create test utilities for mock server generation and configuration fixtures. Include performance benchmarks and load testing.",
        "testStrategy": "Test coverage analysis, CI/CD pipeline integration, automated test execution, performance benchmark validation",
        "priority": "medium",
        "dependencies": [
          22
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "Modernize HTTP Server with Express.js and Streamable Transport",
        "description": "Replace Node.js native HTTP server with Express.js framework and implement streamable HTTP transport mode with /mcp endpoint to support modern MCP tooling. [Updated: 7/13/2025]",
        "details": "Migrate from Node's http.createServer() to Express.js framework following patterns from mcp-graphql-forge repository. Implement streamable HTTP transport mode with /mcp endpoint for bidirectional communication, replacing current SSE transport. Create transport abstraction layer supporting both stdio and HTTP modes with clean switching mechanism. Add Express middleware support for future extensibility. Implement proper request/response handling for MCP protocol over HTTP streams. Create transport factory pattern for instantiating appropriate transport based on configuration. Ensure backward compatibility with existing stdio transport for Claude Code integration. Add proper error handling and connection management for both transport modes.\n<info added on 2025-07-13T16:39:45.818Z>\nAssigned to claude-squad session-1720904000\n</info added on 2025-07-13T16:39:45.818Z>",
        "testStrategy": "Unit tests for Express.js server initialization and middleware registration. Integration tests for streamable HTTP transport with mock MCP clients. End-to-end tests verifying /mcp endpoint functionality and bidirectional communication. Transport switching tests ensuring seamless mode transitions. Compatibility tests with MCP Inspector and other modern tooling. Performance tests comparing new Express implementation with previous native HTTP server. Connection handling tests for both stdio and HTTP transport modes.",
        "status": "done",
        "dependencies": [
          15,
          17
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 26,
        "title": "Create comprehensive documentation including README, API documentation, and usage examples for the hypertool-mcp server",
        "description": "Develop complete documentation suite including project README, API reference documentation, configuration guides, and practical usage examples for the hypertool-mcp proxy server",
        "details": "Create comprehensive documentation structure with the following components:\n\n1. **README.md**: Project overview, quick start guide, installation instructions, basic configuration example, and links to detailed documentation\n\n2. **API Documentation**: Complete API reference using TypeDoc or similar tool, documenting all public interfaces, configuration schemas, and protocol specifications\n\n3. **Configuration Guide**: Detailed documentation of .mcp.json format, toolset configuration options, server connection parameters, and advanced configuration scenarios\n\n4. **Usage Examples**: Practical examples including:\n   - Basic proxy setup with multiple servers\n   - Toolset filtering and namespace configuration\n   - CLI usage for toolset management\n   - Integration with popular MCP clients\n   - Troubleshooting common issues\n\n5. **Architecture Documentation**: Technical overview of proxy architecture, request routing flow, connection management, and tool discovery mechanisms\n\n6. **Developer Guide**: Contributing guidelines, development setup, testing procedures, and code structure overview\n\nEnsure all documentation is clear, well-structured, and includes code examples where appropriate. Use consistent formatting and terminology throughout.",
        "testStrategy": "Documentation validation through the following steps:\n\n1. **README Completeness**: Verify all sections are present (installation, quick start, configuration, usage)\n\n2. **API Documentation Generation**: Run TypeDoc or documentation generator and verify all public APIs are documented\n\n3. **Example Validation**: Test all code examples in documentation to ensure they work correctly\n\n4. **Link Verification**: Check all internal and external links are valid and point to correct resources\n\n5. **Configuration Examples**: Validate all .mcp.json and toolset configuration examples against the actual schemas\n\n6. **User Testing**: Have someone unfamiliar with the project follow the documentation to set up and use the proxy\n\n7. **Documentation Linting**: Use markdown linters to ensure consistent formatting and structure",
        "status": "pending",
        "dependencies": [
          21,
          22,
          24
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "Implement Dynamic Tool Registration System",
        "description": "Replace static toolset filtering with dynamic tool registration/unregistration system that registers tools with flattened names and sends MCP change notifications when toolsets are equipped or unequipped [Updated: 7/14/2025]",
        "details": "Create a dynamic tool registration system replacing the current getAvailableTools() filtering approach. Implement tool registration with name flattening (git.search â†’ git_search) while preserving exact schemas from underlying servers. When toolsets are equipped: 1) Register tools dynamically with the MCP server using flattened names, 2) Send MCP tool change notifications to connected clients, 3) Maintain mapping between flattened names and original server/tool pairs for routing. When toolsets are unequipped: 1) Unregister tools from the MCP server, 2) Send removal notifications to clients, 3) Clean up routing mappings. Preserve the two-layer architecture specified in PRD with tool discovery remaining separate from dynamic registration. Implement transparent proxying ensuring requests to flattened tool names are correctly routed to underlying servers with original names. Handle edge cases: 1) Name conflicts between servers (use server prefixing as fallback), 2) Tools becoming unavailable while registered, 3) Client connections during registration changes, 4) Partial registration failures. Create ToolRegistrationManager class with methods: registerToolset(toolsetId, tools), unregisterToolset(toolsetId), handleToolCall(flattenedName, params). Integrate with existing ToolsetManager for equipped/unequipped events. Ensure atomic registration operations and rollback on failures.\n<info added on 2025-07-14T15:43:43.331Z>\nBased on the user request \"Assigned to claude-squad session-1721000000\", the new text that should be appended to the task's details is:\n\nAssigned to claude-squad session-1721000000\n</info added on 2025-07-14T15:43:43.331Z>",
        "testStrategy": "Unit tests for name flattening logic and conflict resolution. Integration tests for registration/unregistration flows with mock MCP clients verifying change notifications. Test transparent proxying with various tool call scenarios. Simulate edge cases: server disconnections during registration, conflicting tool names, rapid equip/unequip cycles. Verify rollback behavior on partial failures. Performance tests for registration with large toolsets. Test MCP protocol compliance for tool change notifications.",
        "status": "done",
        "dependencies": [
          16,
          17,
          18,
          19
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "Replace current logging system with Pino logger",
        "description": "Implement Pino as the primary logging system throughout the codebase as specified in the PRD's Logging System section. This includes structured logging with CLI configuration, file logging with ISO timestamps, and comprehensive migration from console.* calls to Pino logging.",
        "status": "done",
        "dependencies": [
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          23
        ],
        "priority": "medium",
        "details": "Implement the comprehensive Pino logging system as detailed in the PRD's Logging System section. Key requirements include:\n\n1. **Dependencies**: Install Pino and pino-pretty for development pretty-printing\n2. **Centralized Logger**: Create logger module at src/logging/index.ts with TypeScript interfaces\n3. **CLI Integration**: Add --log-level flag with support for trace, debug, info, warn, error, fatal levels\n4. **File Logging**: Implement file transport with ISO timestamp format (hypertool-mcp_{ISO_timestamp}.log)\n5. **Migration**: Create automated script to replace all console.* calls with appropriate Pino logger calls\n6. **Child Loggers**: Implement child loggers for different modules with proper context\n7. **Transport Support**: Ensure compatibility with both stdio and HTTP transport modes\n8. **Request/Response Logging**: Include comprehensive logging with metadata for tracing\n\nRefer to the PRD's Logging System section for complete technical specifications, configuration details, and implementation requirements.",
        "testStrategy": "Follow the testing strategy outlined in the PRD's Logging System section:\n\n1. **Unit Tests**: Test logger initialization, configuration, and CLI flag handling\n2. **Integration Tests**: Verify transport mode compatibility and file logging functionality\n3. **Migration Tests**: Ensure complete replacement of console.* calls without regressions\n4. **Performance Tests**: Validate async logging performance and file I/O efficiency\n5. **Child Logger Tests**: Test context propagation and module isolation\n6. **Error Handling Tests**: Verify fallback mechanisms and error scenarios\n\nAll tests should validate compliance with the PRD specifications for the logging system.",
        "subtasks": [
          {
            "id": 1,
            "title": "Install Pino dependencies and create initial logger module",
            "description": "Install pino and pino-pretty packages, create src/logging/index.ts with basic logger configuration",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement CLI --log-level flag support",
            "description": "Add --log-level CLI flag with support for all log levels (trace, debug, info, warn, error, fatal)",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement file logging with ISO timestamp format",
            "description": "Create file transport with hypertool-mcp_{ISO_timestamp}.log naming convention",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create migration script for console.* replacement",
            "description": "Build automated script to replace all console.log/warn/error calls with appropriate Pino logger calls",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement child loggers for module integration",
            "description": "Create child logger system for different modules with proper context and integrate across all modules",
            "status": "done",
            "dependencies": [
              1,
              4
            ],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Ensure transport mode compatibility",
            "description": "Verify logger works correctly in both stdio and HTTP transport modes with proper configuration",
            "status": "done",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Implement comprehensive test suite",
            "description": "Create unit, integration, and performance tests covering all logging functionality as specified in PRD",
            "status": "done",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6
            ],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 29,
        "title": "Implement Cursor IDE integration with both one-click install badge and npx script setup",
        "description": "Add Cursor IDE integration through both a one-click install badge for README and an npx script setup command for automated configuration management. Complete implementation details and technical specifications are documented in .taskmaster/docs/prd.cursor.txt.",
        "status": "pending",
        "dependencies": [
          20,
          22
        ],
        "priority": "medium",
        "details": "Implement two installation methods for Cursor IDE integration as specified in .taskmaster/docs/prd.cursor.txt:\n\n1. **One-Click Badge Integration:**\n   - Add prominent installation badge to README.md with deep-link URL\n   - Include provided Cursor deep-link with encoded configuration\n   - Badge should be prominently displayed in installation section\n   - Follow exact specifications from PRD document\n\n2. **NPX Script Setup (`npx -y @toolprint/hypertool-mcp add-cursor`):**\n   - Add CLI argument parsing for 'add-cursor' command\n   - Create cursor configuration management utilities in src/cursor/\n   - Implement configuration workflow per PRD requirements:\n     * Read global Cursor config from ~/.cursor/mcp.json\n     * Create backup at ~/.cursor/mcp.backup.json\n     * Copy ALL existing MCP servers to ~/.cursor/.mcp.ht.json\n     * Add hypertool entry to original config with stdio transport\n   - Add user interaction prompts for config cleanup options\n   - Implement error handling for missing mcp.json files\n   - Create file system utilities for atomic configuration updates\n   - Add proper TypeScript interfaces for Cursor configuration structure\n   - Integrate with existing CLI framework and help system\n\n**Reference Documentation:** See .taskmaster/docs/prd.cursor.txt for complete technical specifications, user stories, implementation requirements, and configuration details.",
        "testStrategy": "Create comprehensive test suite following requirements in .taskmaster/docs/prd.cursor.txt including: CLI argument parsing tests for add-cursor command, file system operation tests with mocked ~/.cursor directory, configuration backup and restore tests, user prompt interaction tests with mocked stdin/stdout, error handling tests for missing configuration files, integration tests with sample Cursor configurations, and end-to-end workflow tests covering both installation methods.",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "Implement npm publishing workflow and package configuration for @toolprint/hypertool-mcp",
        "description": "Configure package.json for scoped npm publication and add justfile commands for publishing workflow with proper build and verification steps, following specifications in the comprehensive PRD document.",
        "status": "pending",
        "dependencies": [
          14,
          22,
          28
        ],
        "priority": "medium",
        "details": "Update package.json configuration for scoped package publication following detailed specifications in `.taskmaster/docs/prd.bin.txt`:\n\n1. **Package.json Updates (per PRD specifications):**\n   - Change `\"name\"` to `\"@toolprint/hypertool-mcp\"`\n   - Add `\"publishConfig\": {\"access\": \"public\"}` for scoped package\n   - Add proper `\"keywords\"`: [\"mcp\", \"model-context-protocol\", \"ai-tools\", \"toolset\", \"proxy\"]\n   - Update `\"repository\"` field with correct GitHub URL\n   - Ensure `\"bin\"` field points to correct executable\n   - Add `\"files\"` array to include only necessary files in published package\n   - Verify all dependencies are properly declared in dependencies/devDependencies\n   - Follow all package metadata requirements from PRD\n\n2. **Justfile Commands (per PRD publishing workflow):**\n   Add publishing commands to justfile following PRD specifications:\n   ```justfile\n   # Build and publish to npm\n   publish: build\n       npm publish --access public\n\n   # Build and publish debug/beta version  \n   publish-beta: build\n       npm version prerelease --preid=beta\n       npm publish --access public --tag beta\n\n   # Build and publish dry-run (test without actually publishing)\n   publish-dry: build\n       npm publish --dry-run --access public\n   ```\n\n3. **Pre-publish Checks (per PRD quality assurance):**\n   - Add pre-publish script to package.json that runs build, test, and lint\n   - Verify TypeScript compilation produces correct output\n   - Ensure binary executable is properly configured and functional\n   - Test scoped package installation and execution locally\n   - Follow all quality gates specified in PRD\n\n4. **Documentation (per PRD requirements):**\n   - Document publishing process for maintainers\n   - Add installation instructions for scoped package\n   - Include npx usage examples\n   - Follow documentation standards from PRD\n\n**Reference**: All technical specifications, package configuration details, publishing workflows, and quality assurance requirements are documented in `.taskmaster/docs/prd.bin.txt`",
        "testStrategy": "Verification steps to ensure publishing workflow works correctly, following PRD quality assurance requirements:\n\n1. **Build Verification (per PRD standards):**\n   - Run `npm run build` and verify no TypeScript errors\n   - Check that dist/ directory contains all necessary files\n   - Verify `node dist/index.js --help` shows correct output\n   - Follow all build verification steps from PRD\n\n2. **Package Configuration (per PRD specifications):**\n   - Run `npm pack` to generate tarball and inspect contents\n   - Verify package.json fields are correctly set according to PRD\n   - Test `just publish-dry` completes successfully without errors\n   - Validate all package metadata meets PRD requirements\n\n3. **Installation Testing (per PRD test scenarios):**\n   - Test local installation: `npm install -g ./`\n   - Verify global command works: `hypertool-mcp --help`\n   - Test npx execution: `npx @toolprint/hypertool-mcp --help`\n   - Follow all installation test cases from PRD\n\n4. **Publishing Workflow (per PRD publishing process):**\n   - Test beta publishing workflow with `just publish-beta`\n   - Verify package appears correctly on npm registry\n   - Test installation from npm: `npm install -g @toolprint/hypertool-mcp`\n   - Confirm binary executable works after npm installation\n   - Execute all quality gates specified in PRD\n\n**Reference**: Comprehensive testing requirements and quality assurance procedures are detailed in `.taskmaster/docs/prd.bin.txt`",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-09T21:55:09.811Z",
      "updated": "2025-07-16T17:58:25.503Z",
      "description": "Tasks for master context"
    }
  }
}