{
  "master": {
    "tasks": [
      {
        "id": 13,
        "title": "Setup TypeScript MCP Server Foundation",
        "description": "Create the basic TypeScript MCP server implementation with stdio and HTTP/SSE transport support following cco-mcp best practices [Updated: 7/10/2025] [Updated: 7/10/2025]",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "Initialize TypeScript project with proper tsconfig.json, package.json with MCP dependencies. Implement base MCP server class with stdio transport support using @modelcontextprotocol/sdk-typescript. Add HTTP/SSE transport layer for web client compatibility. Create server initialization logic with transport selection. Follow patterns from cco-mcp reference implementation for type safety and structure.\n<info added on 2025-07-10T17:26:01.277Z>\nAssigned to claude-squad session-1720651200\n</info added on 2025-07-10T17:26:01.277Z>",
        "testStrategy": "Unit tests for server initialization, transport layer tests for both stdio and HTTP/SSE, integration tests with mock MCP clients",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Implement .mcp.json Configuration Parser",
        "description": "Create parser to read and validate .mcp.json configuration files and extract server connection details [Updated: 7/10/2025]",
        "details": "Build TypeScript configuration parser that reads .mcp.json files, validates schema, and extracts server definitions including transport types (stdio/HTTP), command paths, and connection parameters. Create TypeScript interfaces for configuration structure. Handle file system operations with proper error handling for missing or malformed configuration files. Support both absolute and relative paths for server executables.\n<info added on 2025-07-10T16:23:05.038Z>\nAssigned to claude-squad session-1736519135\n</info added on 2025-07-10T16:23:05.038Z>",
        "testStrategy": "Unit tests with various .mcp.json formats, validation tests for malformed configs, file system mock tests",
        "priority": "high",
        "dependencies": [
          13
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Build Client Connection Manager",
        "description": "Implement connection pool management system to establish and maintain connections to multiple underlying MCP servers [Updated: 7/10/2025]",
        "details": "Create connection manager that spawns and maintains connections to underlying MCP servers based on parsed configuration. Implement connection pooling with proper lifecycle management (connect, disconnect, reconnect). Support both stdio and HTTP transport protocols. Handle connection failures with retry logic and connection state tracking. Use TypeScript generics for type-safe connection handling.\n<info added on 2025-07-10T18:34:50.880Z>\nAssigned to claude-squad session-1736539652\n</info added on 2025-07-10T18:34:50.880Z>",
        "testStrategy": "Integration tests with mock MCP servers, connection lifecycle tests, failure scenario tests, concurrent connection tests",
        "priority": "high",
        "dependencies": [
          14
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Develop Tool Discovery Engine",
        "description": "Create system to query underlying servers for available tools and cache results with full TypeScript type safety",
        "details": "Implement tool discovery mechanism that queries connected MCP servers for their available tools using MCP list_tools protocol. Create TypeScript interfaces for tool metadata including schemas, descriptions, and server origins. Build caching layer with TTL and invalidation strategies. Handle tool schema conflicts with namespacing (server.tool_name format). Store tool definitions in memory with efficient lookup structures.",
        "testStrategy": "Unit tests for tool discovery logic, caching tests with TTL validation, schema conflict resolution tests, performance tests for large tool sets",
        "priority": "high",
        "dependencies": [
          15
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Create Request Router",
        "description": "Implement routing system to transparently route incoming tool requests to appropriate underlying servers [Updated: 7/10/2025]",
        "details": "Build request router that intercepts tool calls from clients and routes them to correct underlying MCP servers. Implement tool name resolution with namespace handling. Create request/response transformation layer to maintain protocol compatibility. Handle request parameters validation and response formatting. Add request logging and error propagation from underlying servers.\n<info added on 2025-07-10T19:36:07.189Z>\nAssigned to claude-squad session-1736523380\n</info added on 2025-07-10T19:36:07.189Z>",
        "testStrategy": "Integration tests with multiple mock servers, request routing accuracy tests, error handling tests, performance benchmarks",
        "priority": "high",
        "dependencies": [
          16
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Implement Toolset Configuration System",
        "description": "Create JSON-based toolset configuration allowing users to specify which tools to expose from each server [Updated: 7/10/2025]",
        "details": "Design toolset configuration schema with JSON format supporting server-specific tool inclusion/exclusion rules. Create configuration validator and loader with TypeScript type definitions. Implement toolset filtering logic that respects user preferences. Support wildcard patterns and regex for tool selection. Create default configuration generator based on available tools.\n<info added on 2025-07-10T20:38:15.385Z>\nAssigned to claude-squad session-1736487412\n</info added on 2025-07-10T20:38:15.385Z>",
        "testStrategy": "Schema validation tests, configuration loading tests, tool filtering accuracy tests, wildcard pattern tests",
        "priority": "medium",
        "dependencies": [
          17
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Add Server Health Monitoring",
        "description": "Implement health monitoring system to track underlying server availability with reconnection logic",
        "details": "Create health monitor that periodically checks underlying server availability using MCP ping/health check mechanisms. Implement reconnection logic with exponential backoff for failed connections. Track server status (online/offline/error) and update tool availability accordingly. Add health check scheduling and connection recovery procedures. Emit health events for monitoring.",
        "testStrategy": "Health check interval tests, reconnection logic tests, server failure simulation tests, health event emission tests",
        "priority": "medium",
        "dependencies": [
          15
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Build Configuration Persistence Layer",
        "description": "Create system to save user preferences and toolset configurations with file-based persistence",
        "details": "Implement file-based persistence for user toolset configurations using JSON format. Create configuration file management with atomic writes and backup strategies. Support configuration versioning and migration. Add user preference storage for default toolsets and server settings. Implement configuration validation on load with schema checking.",
        "testStrategy": "File persistence tests, atomic write tests, configuration migration tests, concurrent access tests",
        "priority": "medium",
        "dependencies": [
          18
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "Create CLI Interface for Toolset Management",
        "description": "Develop command-line interface for toolset management operations (create, save, load, list) [Updated: 7/13/2025]",
        "details": "Build CLI using commander.js or similar framework with commands for toolset management. Implement 'create', 'save', 'load', 'list', and 'delete' commands for toolset configurations. Add interactive toolset builder with server and tool selection menus. Create configuration import/export functionality. Include help documentation and command validation.\n<info added on 2025-07-13T16:52:13.067Z>\nAssigned to claude-squad session-1736790037\n</info added on 2025-07-13T16:52:13.067Z>",
        "testStrategy": "CLI command tests, interactive menu tests, configuration import/export tests, help system tests",
        "priority": "medium",
        "dependencies": [
          20
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Implement Error Handling and Logging",
        "description": "Add comprehensive error handling with clear warnings for unavailable servers and failed tool calls",
        "details": "Create structured error handling system with custom error classes for different failure scenarios. Implement logging framework with configurable log levels and output formatting. Add user-friendly error messages for common issues (server unavailable, tool not found, configuration errors). Create error recovery mechanisms and graceful degradation strategies.",
        "testStrategy": "Error scenario tests, logging output tests, error recovery tests, graceful degradation tests",
        "priority": "medium",
        "dependencies": [
          19
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "Add Tool Call Middleware and Debugging",
        "description": "Implement middleware system for tool call logging, debugging, and request/response transformation",
        "details": "Create middleware architecture for tool call interception and processing. Add request/response logging middleware with configurable verbosity. Implement debugging middleware with request tracing and performance metrics. Create tool call analytics middleware for usage tracking. Support middleware chaining and conditional execution based on configuration.",
        "testStrategy": "Middleware execution tests, logging middleware tests, debugging output tests, performance metrics tests",
        "priority": "low",
        "dependencies": [
          17
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "Create Comprehensive Testing Suite",
        "description": "Develop full testing suite including unit tests, integration tests, and end-to-end testing scenarios",
        "details": "Build comprehensive test suite using Jest or similar framework. Create unit tests for all core components with high coverage. Implement integration tests with mock MCP servers and real protocol interactions. Add end-to-end tests simulating complete user workflows. Create test utilities for mock server generation and configuration fixtures. Include performance benchmarks and load testing.",
        "testStrategy": "Test coverage analysis, CI/CD pipeline integration, automated test execution, performance benchmark validation",
        "priority": "medium",
        "dependencies": [
          22
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "Modernize HTTP Server with Express.js and Streamable Transport",
        "description": "Replace Node.js native HTTP server with Express.js framework and implement streamable HTTP transport mode with /mcp endpoint to support modern MCP tooling. [Updated: 7/13/2025]",
        "details": "Migrate from Node's http.createServer() to Express.js framework following patterns from mcp-graphql-forge repository. Implement streamable HTTP transport mode with /mcp endpoint for bidirectional communication, replacing current SSE transport. Create transport abstraction layer supporting both stdio and HTTP modes with clean switching mechanism. Add Express middleware support for future extensibility. Implement proper request/response handling for MCP protocol over HTTP streams. Create transport factory pattern for instantiating appropriate transport based on configuration. Ensure backward compatibility with existing stdio transport for Claude Code integration. Add proper error handling and connection management for both transport modes.\n<info added on 2025-07-13T16:39:45.818Z>\nAssigned to claude-squad session-1720904000\n</info added on 2025-07-13T16:39:45.818Z>",
        "testStrategy": "Unit tests for Express.js server initialization and middleware registration. Integration tests for streamable HTTP transport with mock MCP clients. End-to-end tests verifying /mcp endpoint functionality and bidirectional communication. Transport switching tests ensuring seamless mode transitions. Compatibility tests with MCP Inspector and other modern tooling. Performance tests comparing new Express implementation with previous native HTTP server. Connection handling tests for both stdio and HTTP transport modes.",
        "status": "done",
        "dependencies": [
          15,
          17
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 26,
        "title": "Create comprehensive documentation including README, API documentation, and usage examples for the hypertool-mcp server",
        "description": "Develop complete documentation suite including project README, API reference documentation, configuration guides, and practical usage examples for the hypertool-mcp proxy server",
        "details": "Create comprehensive documentation structure with the following components:\n\n1. **README.md**: Project overview, quick start guide, installation instructions, basic configuration example, and links to detailed documentation\n\n2. **API Documentation**: Complete API reference using TypeDoc or similar tool, documenting all public interfaces, configuration schemas, and protocol specifications\n\n3. **Configuration Guide**: Detailed documentation of .mcp.json format, toolset configuration options, server connection parameters, and advanced configuration scenarios\n\n4. **Usage Examples**: Practical examples including:\n   - Basic proxy setup with multiple servers\n   - Toolset filtering and namespace configuration\n   - CLI usage for toolset management\n   - Integration with popular MCP clients\n   - Troubleshooting common issues\n\n5. **Architecture Documentation**: Technical overview of proxy architecture, request routing flow, connection management, and tool discovery mechanisms\n\n6. **Developer Guide**: Contributing guidelines, development setup, testing procedures, and code structure overview\n\nEnsure all documentation is clear, well-structured, and includes code examples where appropriate. Use consistent formatting and terminology throughout.",
        "testStrategy": "Documentation validation through the following steps:\n\n1. **README Completeness**: Verify all sections are present (installation, quick start, configuration, usage)\n\n2. **API Documentation Generation**: Run TypeDoc or documentation generator and verify all public APIs are documented\n\n3. **Example Validation**: Test all code examples in documentation to ensure they work correctly\n\n4. **Link Verification**: Check all internal and external links are valid and point to correct resources\n\n5. **Configuration Examples**: Validate all .mcp.json and toolset configuration examples against the actual schemas\n\n6. **User Testing**: Have someone unfamiliar with the project follow the documentation to set up and use the proxy\n\n7. **Documentation Linting**: Use markdown linters to ensure consistent formatting and structure",
        "status": "pending",
        "dependencies": [
          21,
          22,
          24
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "Implement Dynamic Tool Registration System",
        "description": "Replace static toolset filtering with dynamic tool registration/unregistration system that registers tools with flattened names and sends MCP change notifications when toolsets are equipped or unequipped [Updated: 7/14/2025]",
        "details": "Create a dynamic tool registration system replacing the current getAvailableTools() filtering approach. Implement tool registration with name flattening (git.search → git_search) while preserving exact schemas from underlying servers. When toolsets are equipped: 1) Register tools dynamically with the MCP server using flattened names, 2) Send MCP tool change notifications to connected clients, 3) Maintain mapping between flattened names and original server/tool pairs for routing. When toolsets are unequipped: 1) Unregister tools from the MCP server, 2) Send removal notifications to clients, 3) Clean up routing mappings. Preserve the two-layer architecture specified in PRD with tool discovery remaining separate from dynamic registration. Implement transparent proxying ensuring requests to flattened tool names are correctly routed to underlying servers with original names. Handle edge cases: 1) Name conflicts between servers (use server prefixing as fallback), 2) Tools becoming unavailable while registered, 3) Client connections during registration changes, 4) Partial registration failures. Create ToolRegistrationManager class with methods: registerToolset(toolsetId, tools), unregisterToolset(toolsetId), handleToolCall(flattenedName, params). Integrate with existing ToolsetManager for equipped/unequipped events. Ensure atomic registration operations and rollback on failures.\n<info added on 2025-07-14T15:43:43.331Z>\nBased on the user request \"Assigned to claude-squad session-1721000000\", the new text that should be appended to the task's details is:\n\nAssigned to claude-squad session-1721000000\n</info added on 2025-07-14T15:43:43.331Z>",
        "testStrategy": "Unit tests for name flattening logic and conflict resolution. Integration tests for registration/unregistration flows with mock MCP clients verifying change notifications. Test transparent proxying with various tool call scenarios. Simulate edge cases: server disconnections during registration, conflicting tool names, rapid equip/unequip cycles. Verify rollback behavior on partial failures. Performance tests for registration with large toolsets. Test MCP protocol compliance for tool change notifications.",
        "status": "in-progress",
        "dependencies": [
          16,
          17,
          18,
          19
        ],
        "priority": "high",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-09T21:55:09.811Z",
      "updated": "2025-07-14T15:44:19.173Z",
      "description": "Tasks for master context"
    }
  }
}