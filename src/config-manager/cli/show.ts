/**
 * CLI command for showing HyperTool configuration overview
 */

import { Command } from 'commander';
import { theme, semantic } from '../../utils/theme.js';
import { promises as fs } from 'fs';
import { join } from 'path';
import { homedir } from 'os';
import { ConfigurationManager } from '../index.js';
import { output } from '../../utils/output.js';

/**
 * Check if a server configuration references HyperTool itself
 */
function checkSelfReferencingServer(config: any): boolean {
  if (config.type === 'stdio' && config.command) {
    // Check for common patterns that indicate HyperTool MCP
    const command = config.command.toLowerCase();
    const args = config.args || [];
    
    // Direct command references
    if (command === 'hypertool-mcp' || command.endsWith('/hypertool-mcp')) {
      return true;
    }
    
    // NPX references to our package
    if ((command === 'npx' || command.endsWith('/npx')) && args.length > 0) {
      for (const arg of args) {
        const argLower = arg.toLowerCase();
        if (argLower === '@toolprint/hypertool-mcp' || 
            argLower === 'hypertool-mcp' ||
            argLower.includes('@toolprint/hypertool-mcp')) {
          return true;
        }
      }
    }
    
    // Node references to our package
    if ((command === 'node' || command.endsWith('/node')) && args.length > 0) {
      for (const arg of args) {
        const argLower = arg.toLowerCase();
        if (argLower.includes('hypertool-mcp') || argLower.includes('@toolprint/hypertool-mcp')) {
          return true;
        }
      }
    }
  }
  
  return false;
}

interface ServerInfo {
  name: string;
  type: string;
  details: string;
  source?: string;
  healthy: boolean;
  warning?: string;
}

interface ApplicationStatus {
  name: string;
  installed: boolean;
  configPath?: string;
  hasConfig?: boolean;
}

interface ToolsetInfo {
  name: string;
  description?: string;
  toolCount: number;
  autoGenerated: boolean;
  apps: string[];
}

export function createShowCommand(): Command {
  const show = new Command('show');
  
  show
    .description('Show overview of HyperTool configuration and status')
    .option('--json', 'Output in JSON format')
    .action(async (options) => {
      try {
        const configManager = new ConfigurationManager();
        await configManager.initialize();
        
        const basePath = join(homedir(), '.toolprint/hypertool-mcp');
        
        // Gather all information
        const mcpServers = await getMcpServers(basePath);
        const applications = await getApplicationStatus(configManager);
        const toolsets = await getToolsets(basePath);
        const healthStatus = await checkHealth(basePath, mcpServers, applications);
        
        if (options.json) {
          // Output as JSON
          const result = {
            mcpServers,
            applications,
            toolsets,
            health: healthStatus
          };
          output.log(JSON.stringify(result, null, 2));
        } else {
          // Display formatted output
          output.displayHeader('üõ†Ô∏è  HyperTool Configuration Overview');
          output.displaySpaceBuffer(1);
          
          // MCP Servers section
          displayMcpServers(mcpServers);
          
          // Applications section
          displayApplications(applications);
          
          // Toolsets section
          displayToolsets(toolsets);
          
          // Help link
          output.displayHelpContext('  For detailed help, visit: https://github.com/toolprint/hypertool-mcp');
        }
        
      } catch (error) {
        output.error('‚ùå Failed to show configuration:');
        output.error(error instanceof Error ? error.message : String(error));
        process.exit(1);
      }
    });
  
  return show;
}

async function getMcpServers(basePath: string): Promise<ServerInfo[]> {
  const servers: ServerInfo[] = [];
  
  try {
    const mcpConfigPath = join(basePath, 'mcp.json');
    const content = await fs.readFile(mcpConfigPath, 'utf-8');
    const config = JSON.parse(content);
    
    if (config.mcpServers) {
      for (const [name, serverConfig] of Object.entries(config.mcpServers)) {
        const server = serverConfig as any;
        let details = '';
        
        switch (server.type) {
          case 'stdio':
            details = server.command || 'Unknown command';
            if (server.args && Array.isArray(server.args)) {
              details += ' ' + server.args.join(' ');
            }
            break;
          case 'http':
          case 'sse':
          case 'websocket':
            details = server.url || 'Unknown URL';
            break;
          default:
            details = 'Unknown transport details';
        }
        
        // Get source from metadata if available
        let source = 'Unknown';
        if (config._metadata?.sources?.[name]) {
          source = config._metadata.sources[name].app;
        }
        
        // Check for self-referencing HyperTool configuration
        const isSelfReferencing = checkSelfReferencingServer(server);
        
        servers.push({
          name,
          type: server.type || 'unknown',
          details,
          source,
          healthy: !isSelfReferencing,
          warning: isSelfReferencing ? 'Self-referencing HyperTool configuration' : undefined
        });
      }
    }
  } catch (error) {
    // Config file doesn't exist or is invalid
  }
  
  return servers;
}

async function getApplicationStatus(configManager: ConfigurationManager): Promise<ApplicationStatus[]> {
  const applications: ApplicationStatus[] = [];
  const registry = (configManager as any).registry;
  
  try {
    const apps = await registry.getEnabledApplications();
    
    for (const [appId, app] of Object.entries(apps)) {
      const appDef = app as any;
      const installed = await registry.isApplicationInstalled(appDef);
      const platformConfig = registry.getPlatformConfig(appDef);
      
      let configPath: string | undefined;
      let hasConfig = false;
      
      if (installed && platformConfig) {
        configPath = registry.resolvePath(platformConfig.configPath);
        if (appDef.detection.type === 'project-local') {
          configPath = join(process.cwd(), platformConfig.configPath.replace('./', ''));
        }
        
        if (configPath) {
          try {
            await fs.access(configPath);
            hasConfig = true;
          } catch {
            hasConfig = false;
          }
        }
      }
      
      applications.push({
        name: appDef.name,
        installed,
        configPath,
        hasConfig
      });
    }
  } catch (error) {
    // Error getting applications
  }
  
  return applications;
}

async function getToolsets(basePath: string): Promise<ToolsetInfo[]> {
  const toolsets: ToolsetInfo[] = [];
  
  try {
    const prefsPath = join(basePath, 'preferences.json');
    const content = await fs.readFile(prefsPath, 'utf-8');
    const prefs = JSON.parse(content);
    
    if (prefs.toolsets) {
      for (const [id, toolset] of Object.entries(prefs.toolsets)) {
        const ts = toolset as any;
        
        // Find which apps use this toolset
        const apps: string[] = [];
        if (prefs.appDefaults) {
          for (const [appId, defaultToolset] of Object.entries(prefs.appDefaults)) {
            if (defaultToolset === id) {
              apps.push(appId);
            }
          }
        }
        
        toolsets.push({
          name: ts.name || id,
          description: ts.description,
          toolCount: ts.tools?.length || 0,
          autoGenerated: ts.metadata?.autoGenerated || false,
          apps
        });
      }
    }
  } catch (error) {
    // Preferences file doesn't exist or is invalid
  }
  
  return toolsets;
}

interface HealthStatus {
  healthy: boolean;
  issues: string[];
  warnings: string[];
  suggestions: string[];
}

async function checkHealth(
  basePath: string, 
  servers: ServerInfo[], 
  applications: ApplicationStatus[]
): Promise<HealthStatus> {
  const issues: string[] = [];
  const warnings: string[] = [];
  const suggestions: string[] = [];
  
  // Check if config directory exists
  try {
    await fs.access(basePath);
  } catch {
    issues.push('HyperTool configuration directory not found');
    suggestions.push(`Run 'hypertool-mcp config backup' to initialize configuration`);
  }
  
  // Check if any servers are configured
  if (servers.length === 0) {
    warnings.push('No MCP servers configured');
    suggestions.push(`Run 'hypertool-mcp config backup' to import MCP servers from applications`);
  }
  
  // Check if any applications are configured
  const installedApps = applications.filter(app => app.installed);
  if (installedApps.length === 0) {
    warnings.push('No supported applications detected');
    suggestions.push('Install Claude Desktop, Cursor, or Claude Code to use HyperTool');
  }
  
  // Check if applications have HyperTool deployed (excluding Claude Code which uses project-local configs)
  const deployableApps = applications.filter(app => 
    app.installed && app.name !== 'Claude Code' && app.name !== 'Claude Code (User)'
  );
  const deployedApps = deployableApps.filter(app => app.hasConfig);
  
  if (deployableApps.length > 0 && deployedApps.length === 0) {
    warnings.push('HyperTool not deployed to any deployable applications');
    suggestions.push(`Run 'hypertool-mcp config deploy' to deploy HyperTool to applications`);
  }
  
  // Check for invalid configurations
  const invalidServers = servers.filter(s => !s.healthy);
  if (invalidServers.length > 0) {
    for (const server of invalidServers) {
      if (server.warning) {
        issues.push(`Server '${server.name}': ${server.warning}`);
      }
    }
  }
  
  // Check for toolset issues
  try {
    const prefsPath = join(basePath, 'preferences.json');
    const content = await fs.readFile(prefsPath, 'utf-8');
    const prefs = JSON.parse(content);
    
    if (!prefs.toolsets || Object.keys(prefs.toolsets).length === 0) {
      warnings.push('No toolsets configured');
      suggestions.push('Toolsets help organize MCP tools by application context');
    }
  } catch {
    // Preferences file doesn't exist
  }
  
  const healthy = issues.length === 0;
  
  return {
    healthy,
    issues,
    warnings,
    suggestions
  };
}

function displayMcpServers(servers: ServerInfo[]): void {
  output.displaySubHeader('üì° MCP Servers');
  
  if (servers.length === 0) {
    output.warn('  No MCP servers configured');
  } else {
    output.info(`  Total: ${servers.length} server(s)`);
    output.displaySpaceBuffer(1);
    
    // Group by transport type
    const byType = servers.reduce((acc, server) => {
      if (!acc[server.type]) acc[server.type] = [];
      acc[server.type].push(server);
      return acc;
    }, {} as Record<string, ServerInfo[]>);
    
    for (const [type, typeServers] of Object.entries(byType)) {
      output.displayInstruction(`  ${theme.warning(type.toUpperCase())} Transport (${typeServers.length}):`);
      for (const server of typeServers) {
        const healthIcon = server.healthy ? 'üü¢' : 'üî¥';
        output.info(`    ${healthIcon} ${theme.primary(server.name)}`);
        output.info(`      ${theme.muted(server.details)}`);
        if (server.source) {
          output.info(`      ${theme.muted(`Source: ${server.source}`)}`);
        }
        if (server.warning) {
          output.warn(`      ‚ö†Ô∏è  ${server.warning}`);
        }
      }
      output.displaySpaceBuffer(1);
    }
  }
}

function displayApplications(applications: ApplicationStatus[]): void {
  output.displaySubHeader('üñ•Ô∏è  Applications');
  
  if (applications.length === 0) {
    output.warn('  No applications configured');
  } else {
    const installed = applications.filter(app => app.installed);
    const configured = applications.filter(app => app.hasConfig);
    
    output.info(`  Detected: ${installed.length}/${applications.length}`);
    output.info(`  Configured: ${configured.length}/${installed.length}`);
    output.displaySpaceBuffer(1);
    
    for (const app of applications) {
      const status = app.installed 
        ? (app.hasConfig ? '‚úÖ' : '‚ö†Ô∏è ') 
        : '‚ùå';
      output.displayInstruction(`  ${status} ${theme.primary(app.name)}`);
      
      if (app.installed) {
        if (app.configPath) {
          output.info(`     ${theme.muted(app.configPath)}`);
        }
        if (!app.hasConfig && app.name !== 'Claude Code' && app.name !== 'Claude Code (User)') {
          output.info(`     ${theme.warning('Not configured for HyperTool')}`);
        }
      } else {
        output.info(`     ${theme.muted('Not installed')}`);
      }
    }
  }
  output.displaySpaceBuffer(1);
}

function displayToolsets(toolsets: ToolsetInfo[]): void {
  output.displaySubHeader('üß∞ Toolsets');
  
  if (toolsets.length === 0) {
    output.warn('  No toolsets configured');
  } else {
    output.info(`  Total: ${toolsets.length} toolset(s)`);
    output.displaySpaceBuffer(1);
    
    for (const toolset of toolsets) {
      const autoGen = toolset.autoGenerated ? theme.warning(' (auto)') : '';
      output.displayInstruction(`  ‚Ä¢ ${theme.primary(toolset.name)}${autoGen}`);
      
      if (toolset.description) {
        output.info(`    ${theme.muted(toolset.description)}`);
      }
      
      output.info(`    ${theme.muted(`Tools: ${toolset.toolCount}`)}`);
      
      if (toolset.apps.length > 0) {
        output.info(`    ${theme.muted(`Used by: ${toolset.apps.join(', ')}`)}`);
      }
    }
  }
  output.displaySpaceBuffer(1);
}

